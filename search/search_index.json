{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Selamat Datang di Repository Tugas Komputasi Numerik \u00b6 NAMA : ABD. KIFLI NIM : 180411100033 PRODI : TEKNIK INFORMATIKA FAKULTAS : TEKNIK","title":"Beranda"},{"location":"#selamat-datang-di-repository-tugas-komputasi-numerik","text":"NAMA : ABD. KIFLI NIM : 180411100033 PRODI : TEKNIK INFORMATIKA FAKULTAS : TEKNIK","title":"Selamat Datang di Repository Tugas Komputasi Numerik"},{"location":"tugas1/","text":"DERET MACLAURIN \u00b6 Deret MacLaurin merupakan suatu fungsi f(x) yang memiliki turunan f'(x) f'(x) , f\u201d(x) f\u201d(x) , f\u201d'(x) f\u201d'(x) , dan seterusnya yang kontinyu dalam interval I dan a a , x x I maka untuk x x disekitar a a yaitu |x \u2013 a| < , f(x) |x \u2013 a| < , f(x) dapat diekspansi kedalam Deret Taylor. contoh Deret Maclaurin : $$ f(x) = f(0)+ \\frac{f^1(0)x}{1!}+ \\frac{f 2(0)x 2}{2!}+.......+ \\frac{f n(0)x n}{n!} $$ atau juga bisa disebut dengan: $$ f(x)=\\frac{d^2f(x)}{d(x)} $$ Soal \u00b6 tentukan e^2x e^2x dengan x x = 4 dan ekspansi eror < 0,001. Penyelesaian \u00b6 Dalam banyak masalah terapan, pilihan basis yang mudah digunakan adalah bilangan irasional e e = 2,718281828... Bilangan ini disebut basis natural . Fungsi f(x) = ex f(x) = ex disebut sebagai fungsi eksponensial natural. . Pastikan bahwa dalam melihat fungsi eksponensial f(x) = ex f(x) = ex , e e adalah konstanta 2,718281828\u2026, sedangkan x x adalah variabel. cara perhitungannya adalah sebagai berikut: $$ f(x) = f(0)+ \\frac{f^1(0)}{1!}x+ \\frac{f 2(0)}{2!}x 2+\\frac{f 3(0)}{3!}x 3+\\frac{f 4(0)}{4!}x 4+.......+ \\frac{f n(0)}{n!}x n $$ f(x) = f(0)+ \\frac{2}{1!}x+ \\frac{4}{2!}x^2+\\frac{8}{3!}x^3+\\frac{16}{4!}x^4+.......+ \\frac{2^n}{n!}x^n f(x) = f(0)+ \\frac{2}{1!}x+ \\frac{4}{2!}x^2+\\frac{8}{3!}x^3+\\frac{16}{4!}x^4+.......+ \\frac{2^n}{n!}x^n Jika nilai x x diganti dengan 4 maka hasilnya adalah 296,99 Listing Program \u00b6 Untuk membuat program agar dapat mengekspansi bilangan e^2x e^2x dengan nilai x=4 hingga nilai menjadi kurang dari 0,001 bisa dibuat dengan listing program sebagai berikut. import math x = 4 hsl = 1 a = 0 b = 1 ulang = 1 while hsl > 0.001 : fx = 0 fy = 0 for i in range ( a ): fx += ( 2 ** i ) * x ** i / math . factorial ( i ) for j in range ( b ): fy += ( 2 ** j ) * x ** j / math . factorial ( j ) hsl = fy - fx a += 1 b += 1 print ( \"perulangan ke\" , ulang , \"= \" , hsl ) ulang += 1 Output: \u00b6 perulangan ke 1 = 1.0 perulangan ke 2 = 8.0 perulangan ke 3 = 32.0 perulangan ke 4 = 85.33333333333333 perulangan ke 5 = 170.66666666666669 perulangan ke 6 = 273.0666666666666 perulangan ke 7 = 364.08888888888896 perulangan ke 8 = 416.1015873015872 perulangan ke 9 = 416.1015873015872 perulangan ke 10 = 369.8680776014112 perulangan ke 11 = 295.89446208112895 perulangan ke 12 = 215.195972422639 perulangan ke 13 = 143.46398161509296 perulangan ke 14 = 88.28552714774924 perulangan ke 15 = 50.448872655856576 perulangan ke 16 = 26.90606541645684 perulangan ke 17 = 13.45303270822842 perulangan ke 18 = 6.330838921519444 perulangan ke 19 = 2.8137061873417224 perulangan ke 20 = 1.184718394670199 perulangan ke 21 = 0.47388735786807956 perulangan ke 22 = 0.18052851728316455 perulangan ke 23 = 0.06564673355751438 perulangan ke 24 = 0.022833646454728296 perulangan ke 25 = 0.0076112154847578495 perulangan ke 26 = 0.0024355889549951826 perulangan ke 27 = 0.0007494119863622473 MathJax.Hub.Config({ tex2jax:{inlineMath:[['$$','$$']]} });","title":"Tugas 1"},{"location":"tugas1/#deret-maclaurin","text":"Deret MacLaurin merupakan suatu fungsi f(x) yang memiliki turunan f'(x) f'(x) , f\u201d(x) f\u201d(x) , f\u201d'(x) f\u201d'(x) , dan seterusnya yang kontinyu dalam interval I dan a a , x x I maka untuk x x disekitar a a yaitu |x \u2013 a| < , f(x) |x \u2013 a| < , f(x) dapat diekspansi kedalam Deret Taylor. contoh Deret Maclaurin : $$ f(x) = f(0)+ \\frac{f^1(0)x}{1!}+ \\frac{f 2(0)x 2}{2!}+.......+ \\frac{f n(0)x n}{n!} $$ atau juga bisa disebut dengan: $$ f(x)=\\frac{d^2f(x)}{d(x)} $$","title":"DERET MACLAURIN"},{"location":"tugas1/#soal","text":"tentukan e^2x e^2x dengan x x = 4 dan ekspansi eror < 0,001.","title":"Soal"},{"location":"tugas1/#penyelesaian","text":"Dalam banyak masalah terapan, pilihan basis yang mudah digunakan adalah bilangan irasional e e = 2,718281828... Bilangan ini disebut basis natural . Fungsi f(x) = ex f(x) = ex disebut sebagai fungsi eksponensial natural. . Pastikan bahwa dalam melihat fungsi eksponensial f(x) = ex f(x) = ex , e e adalah konstanta 2,718281828\u2026, sedangkan x x adalah variabel. cara perhitungannya adalah sebagai berikut: $$ f(x) = f(0)+ \\frac{f^1(0)}{1!}x+ \\frac{f 2(0)}{2!}x 2+\\frac{f 3(0)}{3!}x 3+\\frac{f 4(0)}{4!}x 4+.......+ \\frac{f n(0)}{n!}x n $$ f(x) = f(0)+ \\frac{2}{1!}x+ \\frac{4}{2!}x^2+\\frac{8}{3!}x^3+\\frac{16}{4!}x^4+.......+ \\frac{2^n}{n!}x^n f(x) = f(0)+ \\frac{2}{1!}x+ \\frac{4}{2!}x^2+\\frac{8}{3!}x^3+\\frac{16}{4!}x^4+.......+ \\frac{2^n}{n!}x^n Jika nilai x x diganti dengan 4 maka hasilnya adalah 296,99","title":"Penyelesaian"},{"location":"tugas1/#listing-program","text":"Untuk membuat program agar dapat mengekspansi bilangan e^2x e^2x dengan nilai x=4 hingga nilai menjadi kurang dari 0,001 bisa dibuat dengan listing program sebagai berikut. import math x = 4 hsl = 1 a = 0 b = 1 ulang = 1 while hsl > 0.001 : fx = 0 fy = 0 for i in range ( a ): fx += ( 2 ** i ) * x ** i / math . factorial ( i ) for j in range ( b ): fy += ( 2 ** j ) * x ** j / math . factorial ( j ) hsl = fy - fx a += 1 b += 1 print ( \"perulangan ke\" , ulang , \"= \" , hsl ) ulang += 1","title":"Listing Program"},{"location":"tugas1/#output","text":"perulangan ke 1 = 1.0 perulangan ke 2 = 8.0 perulangan ke 3 = 32.0 perulangan ke 4 = 85.33333333333333 perulangan ke 5 = 170.66666666666669 perulangan ke 6 = 273.0666666666666 perulangan ke 7 = 364.08888888888896 perulangan ke 8 = 416.1015873015872 perulangan ke 9 = 416.1015873015872 perulangan ke 10 = 369.8680776014112 perulangan ke 11 = 295.89446208112895 perulangan ke 12 = 215.195972422639 perulangan ke 13 = 143.46398161509296 perulangan ke 14 = 88.28552714774924 perulangan ke 15 = 50.448872655856576 perulangan ke 16 = 26.90606541645684 perulangan ke 17 = 13.45303270822842 perulangan ke 18 = 6.330838921519444 perulangan ke 19 = 2.8137061873417224 perulangan ke 20 = 1.184718394670199 perulangan ke 21 = 0.47388735786807956 perulangan ke 22 = 0.18052851728316455 perulangan ke 23 = 0.06564673355751438 perulangan ke 24 = 0.022833646454728296 perulangan ke 25 = 0.0076112154847578495 perulangan ke 26 = 0.0024355889549951826 perulangan ke 27 = 0.0007494119863622473 MathJax.Hub.Config({ tex2jax:{inlineMath:[['$$','$$']]} });","title":"Output:"},{"location":"tugas2/","text":"Program Metode Newton Raphson Pada Fungsi Non Linear \u00b6 Metode Newthon Raphson \u00b6 Metode Newton-Raphson adalah metode pencarian akar suatu fungsi f(x) f(x) dengan pendekatan satu titik, dimana fungsi f(x) f(x) mempunyai turunan. Metode ini dianggap lebih mudah dari Metode (Bisection Method) karena metode ini menggunakan pendekatan satu titik sebagai titik awal. Semakin dekat titik awal yang kita pilih dengan akar sebenarnya, maka semakin cepat konvergen ke akarnya. Prosedur Metode Newton : menentukan x_0 x_0 sebagai titik awal, kemudian menarik garis lurus (misal garis imath ) yang menyinggung titik f(x_0) f(x_0) . Hal ini berakibat garis imath memotong sumbu x x di titik x_1 x_1 Setelah itu diulangi langkah sebelumnya tapi sekarang x_1 x_1 dianggap sebagai titik awalnya. Dari mengulang langkah-langkah sebelumnya akan mendapatkan x_2 , x_3 , ... , x_n x_2 , x_3 , ... , x_n dengan x_n x_n yang diperoleh adalah bilangan riil yang merupakan akar atau mendekati akar yang sebenarnya. Perhatikan gambar diatas untuk menurunkan rumus Metode Newton-Raphson Algoritma Metode Newton Repshon \u00b6 Listing Program \u00b6 #Program python untuk memperkirakan akar polinomial #menggunakan metode newton-raphson import math #f(x) - fungsi polynomial def f ( x ): function = ( x ** 3 ) - ( 2 * x ) - 1 return function def derivative ( x ): #berfungsi untuk menemukan turunan dari polinomial h = 0.000001 derivative = ( f ( x + h ) - f ( x )) / h return derivative def newton_raphson ( x ): return ( x - ( f ( x ) / derivative ( x ))) # p - titik awal mis. nilai lebih dekat ke root # n - jmulah iterasi def perulangan ( p , n ): print ( \"Banyak Iterasinya =\" , n ) x = p for i in range ( n ): x = newton_raphson ( x ) print ( \"perulangan ke-\" , i + 1 , \"=\" , x ) return ( \"\" ) print ( perulangan ( 1 , 12 )) #cetakan akar polinomial x ^ 3 - 2x - 1 menggunakan 3 iterasi dan ambil titik awal sebagai 1 Output: \u00b6 Banyak Iterasinya = 12 perulangan ke- 1 = 2.999994000093219 perulangan ke- 2 = 2.199996832141079 perulangan ke- 3 = 1.7808294919560141 perulangan ke- 4 = 1.6363030634057565 perulangan ke- 5 = 1.618304588651506 perulangan ke- 6 = 1.6180340496697716 perulangan ke- 7 = 1.6180339887499484 perulangan ke- 8 = 1.6180339887498947 perulangan ke- 9 = 1.618033988749895 perulangan ke- 10 = 1.618033988749895 perulangan ke- 11 = 1.618033988749895 perulangan ke- 12 = 1.618033988749895 MathJax.Hub.Config({ tex2jax:{inlineMath:[['$$','$$']]} });","title":"Tugas 2"},{"location":"tugas2/#program-metode-newton-raphson-pada-fungsi-non-linear","text":"","title":"Program Metode Newton Raphson Pada Fungsi Non Linear"},{"location":"tugas2/#metode-newthon-raphson","text":"Metode Newton-Raphson adalah metode pencarian akar suatu fungsi f(x) f(x) dengan pendekatan satu titik, dimana fungsi f(x) f(x) mempunyai turunan. Metode ini dianggap lebih mudah dari Metode (Bisection Method) karena metode ini menggunakan pendekatan satu titik sebagai titik awal. Semakin dekat titik awal yang kita pilih dengan akar sebenarnya, maka semakin cepat konvergen ke akarnya. Prosedur Metode Newton : menentukan x_0 x_0 sebagai titik awal, kemudian menarik garis lurus (misal garis imath ) yang menyinggung titik f(x_0) f(x_0) . Hal ini berakibat garis imath memotong sumbu x x di titik x_1 x_1 Setelah itu diulangi langkah sebelumnya tapi sekarang x_1 x_1 dianggap sebagai titik awalnya. Dari mengulang langkah-langkah sebelumnya akan mendapatkan x_2 , x_3 , ... , x_n x_2 , x_3 , ... , x_n dengan x_n x_n yang diperoleh adalah bilangan riil yang merupakan akar atau mendekati akar yang sebenarnya. Perhatikan gambar diatas untuk menurunkan rumus Metode Newton-Raphson","title":"Metode Newthon Raphson"},{"location":"tugas2/#algoritma-metode-newton-repshon","text":"","title":"Algoritma Metode Newton Repshon"},{"location":"tugas2/#listing-program","text":"#Program python untuk memperkirakan akar polinomial #menggunakan metode newton-raphson import math #f(x) - fungsi polynomial def f ( x ): function = ( x ** 3 ) - ( 2 * x ) - 1 return function def derivative ( x ): #berfungsi untuk menemukan turunan dari polinomial h = 0.000001 derivative = ( f ( x + h ) - f ( x )) / h return derivative def newton_raphson ( x ): return ( x - ( f ( x ) / derivative ( x ))) # p - titik awal mis. nilai lebih dekat ke root # n - jmulah iterasi def perulangan ( p , n ): print ( \"Banyak Iterasinya =\" , n ) x = p for i in range ( n ): x = newton_raphson ( x ) print ( \"perulangan ke-\" , i + 1 , \"=\" , x ) return ( \"\" ) print ( perulangan ( 1 , 12 )) #cetakan akar polinomial x ^ 3 - 2x - 1 menggunakan 3 iterasi dan ambil titik awal sebagai 1","title":"Listing Program"},{"location":"tugas2/#output","text":"Banyak Iterasinya = 12 perulangan ke- 1 = 2.999994000093219 perulangan ke- 2 = 2.199996832141079 perulangan ke- 3 = 1.7808294919560141 perulangan ke- 4 = 1.6363030634057565 perulangan ke- 5 = 1.618304588651506 perulangan ke- 6 = 1.6180340496697716 perulangan ke- 7 = 1.6180339887499484 perulangan ke- 8 = 1.6180339887498947 perulangan ke- 9 = 1.618033988749895 perulangan ke- 10 = 1.618033988749895 perulangan ke- 11 = 1.618033988749895 perulangan ke- 12 = 1.618033988749895 MathJax.Hub.Config({ tex2jax:{inlineMath:[['$$','$$']]} });","title":"Output:"},{"location":"tugas3/","text":"Eliminasi Gauss \u00b6 Metode eliminasi gauss termasuk dalam metode penyelesaian persamaan linear dengan cara langsung. Inti dari metode ini adalah membawa persamaan kedalam bentuk matriks dan menyederhanakan matriks menjadi bentuk segitiga atas. Setelah mendapat bentuk matriks tersebut dilakukan subtitusi balik untuk mendapat nilai dari akar persamaan tadi. Untuk lebih jelasnya kita perhatikan contoh berikut. Contoh: Berikut adalah suatu sistem persamaan linier $$ 2x + y -z = 8 (L_1) $$ -3x - y + 2z = -11 (L_2) -3x - y + 2z = -11 (L_2) -2x + y + 2z = -3 (L_3) -2x + y + 2z = -3 (L_3) Cara penyelesaian dengan menggunakan metode eliminasi Gauss dijabarkan dalam tabel berikut: Listing Program : import numpy as np #Membuat Matrix A = [] B = [] n = int ( input ( \"Tentukan ordo Matrix: \" )) for i in range ( n ): baris = [] for i in range ( n ): a = int ( input ( \"Masukkan elemen Matrix: \" )) baris . append ( a ) A . append ( baris ) for i in range ( n ): h = int ( input ( \"Masukkan Hasil: \" )) B . append ( h ) Matrix = np . array ( A , float ) Hasil = np . array ( B , float ) n = len ( Matrix ) #Eliminasi Gauss for k in range ( 0 , n - 1 ): for i in range ( k + 1 , n ): if Matrix [ i , k ] != 0 : lam = Matrix [ i , k ] / Matrix [ k , k ] Matrix [ i , k : n ] = Matrix [ i , k : n ] - ( Matrix [ k , k : n ] * lam ) Hasil [ i ] = Hasil [ i ] - ( Hasil [ k ] * lam ) print ( \"Matrix A : \" , ' \\n ' , Matrix ) #Substitusi x = np . zeros ( n , float ) for m in range ( n - 1 , - 1 , - 1 ): x [ m ] = ( Hasil [ m ] - np . dot ( Matrix [ m , m + 1 : n ], x [ m + 1 : n ])) / Matrix [ m , m ] print ( 'Nilai X ' , m + 1 , '=' , x [ m ]) Output: Tentukan ordo Matrix: 3 Masukkan elemen Matrix: 2 Masukkan elemen Matrix: 1 Masukkan elemen Matrix: -1 Masukkan elemen Matrix: -3 Masukkan elemen Matrix: -1 Masukkan elemen Matrix: 2 Masukkan elemen Matrix: -2 Masukkan elemen Matrix: 1 Masukkan elemen Matrix: 2 Masukkan Hasil: 8 Masukkan Hasil: -11 Masukkan Hasil: -3 Matrix A : [[ 2. 1. -1. ] [ 0. 0.5 0.5] [ 0. 0. -1. ]] Nilai X 3 = -1.0 Nilai X 2 = 3.0 Nilai X 1 = 2.0 Jacobi \u00b6 Metode Iterasi Jacobi merupakan salah satu bidang analisis numerik yang digunakan untuk menyelesaikan permasalahan persamaan linier dan sering dijumpai dalam berbagai disiplin ilmu. Metode Iterasi Jacobi merupakan salah satu metode tak langsung, yaitu bermula dari suatu hampiran penyelesaian awal dan kemudian berusaha memperbaiki hampiran dalam tak berhingga namun langkah konvergen. Metode Iterasi Jacobi ini digunakan untuk menyelesaikan persamaan linier berukuran besar dan proporsi koefisien nolnya besar. Listing Program: from pprint import pprint from numpy import array, zeros, diag, diagflat, dot import numpy as np def jacobi(A,b,N=25,x=None): #Membuat iniial guess if x is None: x = zeros(len(A[0])) #Membuat vektor dari elemen matrix A D = diag(A) R = A - diagflat(D) #Iterasi for i in range(N): x = (b - dot(R,x)) / D return x Mat1 = [] Mat2 = [] n = int(input(\"Masukkan Ordo Matrix: \")) for i in range(n): baris=[] for i in range(n): a=int(input(\"Masukkan elemen: \")) baris.append(a) Mat1.append(baris) for i in range(n): h = int(input(\"Masukkan Hasil: \")) Mat2.append(h) A = array(Mat1,float) b = array(Mat2,float) x=len(Mat1) guess = np.zeros(x,float) sol = jacobi(A,b,N=25,x=guess) print(\"A:\") pprint(A) print(\"b:\") pprint(b) print(\"x:\") pprint(sol) Output: Masukkan Ordo Matrix: 3 Masukkan elemen: 2 Masukkan elemen: 1 Masukkan elemen: -1 Masukkan elemen: -3 Masukkan elemen: -1 Masukkan elemen: 2 Masukkan elemen: -2 Masukkan elemen: 1 Masukkan elemen: 2 Masukkan Hasil: 8 Masukkan Hasil: -11 Masukkan Hasil: -3 A: array([[ 2., 1., -1.], [-3., -1., 2.], [-2., 1., 2.]]) b: array([ 8., -11., -3.]) x: array([34.89370728, 81.70007324, 4.78002167]) Gauss Seidel \u00b6 Metode Gauss-Seidel digunakan untuk menyelesaikan sistem persamaan linear (SPL) berukuran besar dan proporsi koefisien nolnya besar, seperti sistem-sistem yang banyak ditemukan dalam sistem persamaan diferensial. Metode iterasi Gauss-Seidel dikembangkan dari gagasan metode iterasi pada solusi persamaan tak linier. Teknik iterasi jarang digunakan untuk menyelesaikan SPL berukuran kecil karena metode-metode langsung seperti metode eliminasi Gauss lebih efisien daripada metode iteratif. Akan tetapi, untuk SPL berukuran besar dengan persentase elemen nol pada matriks koefisien besar, teknik iterasi lebih efisien daripada metode langsung dalam hal penggunaan memori komputer maupun waktu komputasi. Dengan metode iterasi Gauss-Seidel sesatan pembulatan dapat diperkecil karena dapat meneruskan iterasi sampai solusinya seteliti mungkin sesuai dengan batas sesatan yang diperbolehkan. Listing Program: def seidel(a, x ,b): #Mencari Panjang Matrix n = len(a) for j in range(0, n): d = b[j] #Menghitung xi, yi, zi for i in range(0, n): if(j != i): d-=a[j][i] * x[i] x[j] = d / a[j][j] #Solusi return x m=int(input(\"Masukkan Panjang Matrix: \")) a=[] b=[] for k in range(m): mat1=[] for i in range(m): l=float(input(\"Masukkan a\"+str(k+1)+\",\"+str(i+1)+\": \")) mat1.append(l) h=float(input(\"Masukkan Hasil: \")) b.append(h) a.append(mat1) n = 3 x = [0, 0, 0] print(x) for i in range(0, 100): x = seidel(a, x, b) print(x) Output: Masukkan Panjang Matrix: 3 Masukkan a1,1: 4 Masukkan a1,2: -1 Masukkan a1,3: 1 Masukkan Hasil: 7 Masukkan a2,1: 4 Masukkan a2,2: -8 Masukkan a2,3: 1 Masukkan Hasil: -21 Masukkan a3,1: -2 Masukkan a3,2: 1 Masukkan a3,3: 5 Masukkan Hasil: -15 [0, 0, 0] [1.75, 3.5, -3.0] [3.375, 3.9375, -2.4375] [3.34375, 3.9921875, -2.4609375] [3.36328125, 3.9990234375, -2.4544921875] [3.36337890625, 3.9998779296875, -2.4546240234375] [3.36362548828125, 3.999984741210938, -2.4545467529296876] [3.363632873535156, 3.999998092651367, -2.454546469116211] [3.3636361404418946, 3.999999761581421, -2.4545454961395263] [3.363636314430237, 3.999999970197678, -2.454545468267441] [3.3636363596162795, 3.9999999962747097, -2.45454545540843] [3.363636362920785, 3.9999999995343387, -2.454545454738554] [3.363636363568223, 3.999999999941792, -2.454545454561069] [3.3636363636257154, 3.999999999992724, -2.4545454545482586] [3.3636363636352455, 3.9999999999990905, -2.4545454545457197] [3.3636363636362026, 3.9999999999998868, -2.4545454545454963] [3.3636363636363455, 3.999999999999986, -2.454545454545459] [3.363636363636361, 3.9999999999999982, -2.454545454545455] [3.3636363636363633, 4.0, -2.4545454545454546] [3.3636363636363638, 4.0, -2.4545454545454546] [3.3636363636363638, 4.0, -2.4545454545454546] [3.3636363636363638, 4.0, -2.4545454545454546] [3.3636363636363638, 4.0, -2.4545454545454546] [3.3636363636363638, 4.0, -2.4545454545454546] [3.3636363636363638, 4.0, -2.4545454545454546] [3.3636363636363638, 4.0, -2.4545454545454546] [3.3636363636363638, 4.0, -2.4545454545454546] [3.3636363636363638, 4.0, -2.4545454545454546] [3.3636363636363638, 4.0, -2.4545454545454546] [3.3636363636363638, 4.0, -2.4545454545454546] [3.3636363636363638, 4.0, -2.4545454545454546] [3.3636363636363638, 4.0, -2.4545454545454546] [3.3636363636363638, 4.0, -2.4545454545454546] [3.3636363636363638, 4.0, -2.4545454545454546] [3.3636363636363638, 4.0, -2.4545454545454546] [3.3636363636363638, 4.0, -2.4545454545454546] [3.3636363636363638, 4.0, -2.4545454545454546] [3.3636363636363638, 4.0, -2.4545454545454546] [3.3636363636363638, 4.0, -2.4545454545454546] [3.3636363636363638, 4.0, -2.4545454545454546] [3.3636363636363638, 4.0, -2.4545454545454546] [3.3636363636363638, 4.0, -2.4545454545454546] [3.3636363636363638, 4.0, -2.4545454545454546] [3.3636363636363638, 4.0, -2.4545454545454546] [3.3636363636363638, 4.0, -2.4545454545454546] [3.3636363636363638, 4.0, -2.4545454545454546] [3.3636363636363638, 4.0, -2.4545454545454546] [3.3636363636363638, 4.0, -2.4545454545454546] [3.3636363636363638, 4.0, -2.4545454545454546] [3.3636363636363638, 4.0, -2.4545454545454546] [3.3636363636363638, 4.0, -2.4545454545454546] [3.3636363636363638, 4.0, -2.4545454545454546] [3.3636363636363638, 4.0, -2.4545454545454546] [3.3636363636363638, 4.0, -2.4545454545454546] [3.3636363636363638, 4.0, -2.4545454545454546] [3.3636363636363638, 4.0, -2.4545454545454546] [3.3636363636363638, 4.0, -2.4545454545454546] [3.3636363636363638, 4.0, -2.4545454545454546] [3.3636363636363638, 4.0, -2.4545454545454546] [3.3636363636363638, 4.0, -2.4545454545454546] [3.3636363636363638, 4.0, -2.4545454545454546] [3.3636363636363638, 4.0, -2.4545454545454546] [3.3636363636363638, 4.0, -2.4545454545454546] [3.3636363636363638, 4.0, -2.4545454545454546] [3.3636363636363638, 4.0, -2.4545454545454546] [3.3636363636363638, 4.0, -2.4545454545454546] [3.3636363636363638, 4.0, -2.4545454545454546] [3.3636363636363638, 4.0, -2.4545454545454546] [3.3636363636363638, 4.0, -2.4545454545454546] Masukkan Panjang Matrix: 3 Masukkan a1,1: 4 Masukkan a1,2: -1 Masukkan a1,3: 1 Masukkan Hasil: 7 Masukkan a2,1: 4 Masukkan a2,2: -8 Masukkan a2,3: 1 Masukkan Hasil: -21 Masukkan a3,1: -2 Masukkan a3,2: 1 Masukkan a3,3: 5 Masukkan Hasil: 15 [0, 0, 0] [1.75, 3.5, 3.0] [1.875, 3.9375, 2.9625] [1.99375, 3.9921875, 2.9990625] [1.99828125, 3.9990234375, 2.9995078125] [1.99987890625, 3.9998779296875, 2.9999759765625003] [1.99997548828125, 3.9999847412109375, 2.999993247070312] [1.9999978735351562, 3.9999980926513667, 2.999999530883789] [1.9999996404418945, 3.9999997615814205, 2.9999999038604734] [1.9999999644302369, 3.9999999701976776, 2.9999999917325595] [1.9999999946162794, 3.9999999962747097, 2.99999999859157] [1.9999999994207849, 3.9999999995343387, 2.9999999998614464] [1.9999999999182232, 3.999999999941793, 2.999999999978931] [1.9999999999907154, 3.999999999992724, 2.9999999999977414] [1.9999999999987457, 3.9999999999990905, 2.9999999999996803] [1.9999999999998526, 3.9999999999998863, 2.9999999999999636] [1.9999999999999807, 3.999999999999986, 2.999999999999995] [1.9999999999999978, 3.9999999999999987, 2.9999999999999996] [1.9999999999999996, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] MathJax.Hub.Config({ tex2jax:{inlineMath:[['$$','$$']]} });","title":"Tugas 3"},{"location":"tugas3/#eliminasi-gauss","text":"Metode eliminasi gauss termasuk dalam metode penyelesaian persamaan linear dengan cara langsung. Inti dari metode ini adalah membawa persamaan kedalam bentuk matriks dan menyederhanakan matriks menjadi bentuk segitiga atas. Setelah mendapat bentuk matriks tersebut dilakukan subtitusi balik untuk mendapat nilai dari akar persamaan tadi. Untuk lebih jelasnya kita perhatikan contoh berikut. Contoh: Berikut adalah suatu sistem persamaan linier $$ 2x + y -z = 8 (L_1) $$ -3x - y + 2z = -11 (L_2) -3x - y + 2z = -11 (L_2) -2x + y + 2z = -3 (L_3) -2x + y + 2z = -3 (L_3) Cara penyelesaian dengan menggunakan metode eliminasi Gauss dijabarkan dalam tabel berikut: Listing Program : import numpy as np #Membuat Matrix A = [] B = [] n = int ( input ( \"Tentukan ordo Matrix: \" )) for i in range ( n ): baris = [] for i in range ( n ): a = int ( input ( \"Masukkan elemen Matrix: \" )) baris . append ( a ) A . append ( baris ) for i in range ( n ): h = int ( input ( \"Masukkan Hasil: \" )) B . append ( h ) Matrix = np . array ( A , float ) Hasil = np . array ( B , float ) n = len ( Matrix ) #Eliminasi Gauss for k in range ( 0 , n - 1 ): for i in range ( k + 1 , n ): if Matrix [ i , k ] != 0 : lam = Matrix [ i , k ] / Matrix [ k , k ] Matrix [ i , k : n ] = Matrix [ i , k : n ] - ( Matrix [ k , k : n ] * lam ) Hasil [ i ] = Hasil [ i ] - ( Hasil [ k ] * lam ) print ( \"Matrix A : \" , ' \\n ' , Matrix ) #Substitusi x = np . zeros ( n , float ) for m in range ( n - 1 , - 1 , - 1 ): x [ m ] = ( Hasil [ m ] - np . dot ( Matrix [ m , m + 1 : n ], x [ m + 1 : n ])) / Matrix [ m , m ] print ( 'Nilai X ' , m + 1 , '=' , x [ m ]) Output: Tentukan ordo Matrix: 3 Masukkan elemen Matrix: 2 Masukkan elemen Matrix: 1 Masukkan elemen Matrix: -1 Masukkan elemen Matrix: -3 Masukkan elemen Matrix: -1 Masukkan elemen Matrix: 2 Masukkan elemen Matrix: -2 Masukkan elemen Matrix: 1 Masukkan elemen Matrix: 2 Masukkan Hasil: 8 Masukkan Hasil: -11 Masukkan Hasil: -3 Matrix A : [[ 2. 1. -1. ] [ 0. 0.5 0.5] [ 0. 0. -1. ]] Nilai X 3 = -1.0 Nilai X 2 = 3.0 Nilai X 1 = 2.0","title":"Eliminasi Gauss"},{"location":"tugas3/#jacobi","text":"Metode Iterasi Jacobi merupakan salah satu bidang analisis numerik yang digunakan untuk menyelesaikan permasalahan persamaan linier dan sering dijumpai dalam berbagai disiplin ilmu. Metode Iterasi Jacobi merupakan salah satu metode tak langsung, yaitu bermula dari suatu hampiran penyelesaian awal dan kemudian berusaha memperbaiki hampiran dalam tak berhingga namun langkah konvergen. Metode Iterasi Jacobi ini digunakan untuk menyelesaikan persamaan linier berukuran besar dan proporsi koefisien nolnya besar. Listing Program: from pprint import pprint from numpy import array, zeros, diag, diagflat, dot import numpy as np def jacobi(A,b,N=25,x=None): #Membuat iniial guess if x is None: x = zeros(len(A[0])) #Membuat vektor dari elemen matrix A D = diag(A) R = A - diagflat(D) #Iterasi for i in range(N): x = (b - dot(R,x)) / D return x Mat1 = [] Mat2 = [] n = int(input(\"Masukkan Ordo Matrix: \")) for i in range(n): baris=[] for i in range(n): a=int(input(\"Masukkan elemen: \")) baris.append(a) Mat1.append(baris) for i in range(n): h = int(input(\"Masukkan Hasil: \")) Mat2.append(h) A = array(Mat1,float) b = array(Mat2,float) x=len(Mat1) guess = np.zeros(x,float) sol = jacobi(A,b,N=25,x=guess) print(\"A:\") pprint(A) print(\"b:\") pprint(b) print(\"x:\") pprint(sol) Output: Masukkan Ordo Matrix: 3 Masukkan elemen: 2 Masukkan elemen: 1 Masukkan elemen: -1 Masukkan elemen: -3 Masukkan elemen: -1 Masukkan elemen: 2 Masukkan elemen: -2 Masukkan elemen: 1 Masukkan elemen: 2 Masukkan Hasil: 8 Masukkan Hasil: -11 Masukkan Hasil: -3 A: array([[ 2., 1., -1.], [-3., -1., 2.], [-2., 1., 2.]]) b: array([ 8., -11., -3.]) x: array([34.89370728, 81.70007324, 4.78002167])","title":"Jacobi"},{"location":"tugas3/#gauss-seidel","text":"Metode Gauss-Seidel digunakan untuk menyelesaikan sistem persamaan linear (SPL) berukuran besar dan proporsi koefisien nolnya besar, seperti sistem-sistem yang banyak ditemukan dalam sistem persamaan diferensial. Metode iterasi Gauss-Seidel dikembangkan dari gagasan metode iterasi pada solusi persamaan tak linier. Teknik iterasi jarang digunakan untuk menyelesaikan SPL berukuran kecil karena metode-metode langsung seperti metode eliminasi Gauss lebih efisien daripada metode iteratif. Akan tetapi, untuk SPL berukuran besar dengan persentase elemen nol pada matriks koefisien besar, teknik iterasi lebih efisien daripada metode langsung dalam hal penggunaan memori komputer maupun waktu komputasi. Dengan metode iterasi Gauss-Seidel sesatan pembulatan dapat diperkecil karena dapat meneruskan iterasi sampai solusinya seteliti mungkin sesuai dengan batas sesatan yang diperbolehkan. Listing Program: def seidel(a, x ,b): #Mencari Panjang Matrix n = len(a) for j in range(0, n): d = b[j] #Menghitung xi, yi, zi for i in range(0, n): if(j != i): d-=a[j][i] * x[i] x[j] = d / a[j][j] #Solusi return x m=int(input(\"Masukkan Panjang Matrix: \")) a=[] b=[] for k in range(m): mat1=[] for i in range(m): l=float(input(\"Masukkan a\"+str(k+1)+\",\"+str(i+1)+\": \")) mat1.append(l) h=float(input(\"Masukkan Hasil: \")) b.append(h) a.append(mat1) n = 3 x = [0, 0, 0] print(x) for i in range(0, 100): x = seidel(a, x, b) print(x) Output: Masukkan Panjang Matrix: 3 Masukkan a1,1: 4 Masukkan a1,2: -1 Masukkan a1,3: 1 Masukkan Hasil: 7 Masukkan a2,1: 4 Masukkan a2,2: -8 Masukkan a2,3: 1 Masukkan Hasil: -21 Masukkan a3,1: -2 Masukkan a3,2: 1 Masukkan a3,3: 5 Masukkan Hasil: -15 [0, 0, 0] [1.75, 3.5, -3.0] [3.375, 3.9375, -2.4375] [3.34375, 3.9921875, -2.4609375] [3.36328125, 3.9990234375, -2.4544921875] [3.36337890625, 3.9998779296875, -2.4546240234375] [3.36362548828125, 3.999984741210938, -2.4545467529296876] [3.363632873535156, 3.999998092651367, -2.454546469116211] [3.3636361404418946, 3.999999761581421, -2.4545454961395263] [3.363636314430237, 3.999999970197678, -2.454545468267441] [3.3636363596162795, 3.9999999962747097, -2.45454545540843] [3.363636362920785, 3.9999999995343387, -2.454545454738554] [3.363636363568223, 3.999999999941792, -2.454545454561069] [3.3636363636257154, 3.999999999992724, -2.4545454545482586] [3.3636363636352455, 3.9999999999990905, -2.4545454545457197] [3.3636363636362026, 3.9999999999998868, -2.4545454545454963] [3.3636363636363455, 3.999999999999986, -2.454545454545459] [3.363636363636361, 3.9999999999999982, -2.454545454545455] [3.3636363636363633, 4.0, -2.4545454545454546] [3.3636363636363638, 4.0, -2.4545454545454546] [3.3636363636363638, 4.0, -2.4545454545454546] [3.3636363636363638, 4.0, -2.4545454545454546] [3.3636363636363638, 4.0, -2.4545454545454546] [3.3636363636363638, 4.0, -2.4545454545454546] [3.3636363636363638, 4.0, -2.4545454545454546] [3.3636363636363638, 4.0, -2.4545454545454546] [3.3636363636363638, 4.0, -2.4545454545454546] [3.3636363636363638, 4.0, -2.4545454545454546] [3.3636363636363638, 4.0, -2.4545454545454546] [3.3636363636363638, 4.0, -2.4545454545454546] [3.3636363636363638, 4.0, -2.4545454545454546] [3.3636363636363638, 4.0, -2.4545454545454546] [3.3636363636363638, 4.0, -2.4545454545454546] [3.3636363636363638, 4.0, -2.4545454545454546] [3.3636363636363638, 4.0, -2.4545454545454546] [3.3636363636363638, 4.0, -2.4545454545454546] [3.3636363636363638, 4.0, -2.4545454545454546] [3.3636363636363638, 4.0, -2.4545454545454546] [3.3636363636363638, 4.0, -2.4545454545454546] [3.3636363636363638, 4.0, -2.4545454545454546] [3.3636363636363638, 4.0, -2.4545454545454546] [3.3636363636363638, 4.0, -2.4545454545454546] [3.3636363636363638, 4.0, -2.4545454545454546] [3.3636363636363638, 4.0, -2.4545454545454546] [3.3636363636363638, 4.0, -2.4545454545454546] [3.3636363636363638, 4.0, -2.4545454545454546] [3.3636363636363638, 4.0, -2.4545454545454546] [3.3636363636363638, 4.0, -2.4545454545454546] [3.3636363636363638, 4.0, -2.4545454545454546] [3.3636363636363638, 4.0, -2.4545454545454546] [3.3636363636363638, 4.0, -2.4545454545454546] [3.3636363636363638, 4.0, -2.4545454545454546] [3.3636363636363638, 4.0, -2.4545454545454546] [3.3636363636363638, 4.0, -2.4545454545454546] [3.3636363636363638, 4.0, -2.4545454545454546] [3.3636363636363638, 4.0, -2.4545454545454546] [3.3636363636363638, 4.0, -2.4545454545454546] [3.3636363636363638, 4.0, -2.4545454545454546] [3.3636363636363638, 4.0, -2.4545454545454546] [3.3636363636363638, 4.0, -2.4545454545454546] [3.3636363636363638, 4.0, -2.4545454545454546] [3.3636363636363638, 4.0, -2.4545454545454546] [3.3636363636363638, 4.0, -2.4545454545454546] [3.3636363636363638, 4.0, -2.4545454545454546] [3.3636363636363638, 4.0, -2.4545454545454546] [3.3636363636363638, 4.0, -2.4545454545454546] [3.3636363636363638, 4.0, -2.4545454545454546] [3.3636363636363638, 4.0, -2.4545454545454546] [3.3636363636363638, 4.0, -2.4545454545454546] Masukkan Panjang Matrix: 3 Masukkan a1,1: 4 Masukkan a1,2: -1 Masukkan a1,3: 1 Masukkan Hasil: 7 Masukkan a2,1: 4 Masukkan a2,2: -8 Masukkan a2,3: 1 Masukkan Hasil: -21 Masukkan a3,1: -2 Masukkan a3,2: 1 Masukkan a3,3: 5 Masukkan Hasil: 15 [0, 0, 0] [1.75, 3.5, 3.0] [1.875, 3.9375, 2.9625] [1.99375, 3.9921875, 2.9990625] [1.99828125, 3.9990234375, 2.9995078125] [1.99987890625, 3.9998779296875, 2.9999759765625003] [1.99997548828125, 3.9999847412109375, 2.999993247070312] [1.9999978735351562, 3.9999980926513667, 2.999999530883789] [1.9999996404418945, 3.9999997615814205, 2.9999999038604734] [1.9999999644302369, 3.9999999701976776, 2.9999999917325595] [1.9999999946162794, 3.9999999962747097, 2.99999999859157] [1.9999999994207849, 3.9999999995343387, 2.9999999998614464] [1.9999999999182232, 3.999999999941793, 2.999999999978931] [1.9999999999907154, 3.999999999992724, 2.9999999999977414] [1.9999999999987457, 3.9999999999990905, 2.9999999999996803] [1.9999999999998526, 3.9999999999998863, 2.9999999999999636] [1.9999999999999807, 3.999999999999986, 2.999999999999995] [1.9999999999999978, 3.9999999999999987, 2.9999999999999996] [1.9999999999999996, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] MathJax.Hub.Config({ tex2jax:{inlineMath:[['$$','$$']]} });","title":"Gauss Seidel"},{"location":"tugas4/","text":"Recursive Trapezoid \u00b6 Metode trapesium merupakan metode integrasi numerik yang didasarkan pada penjumlahan segmen-segmen berbentuk trapesium. Apabila sebuah integral didekati dengan metode trapesium dengan satu segmen saja. Maka dapat dituliskan persamaan sebagai berikut : Aturan trapesium bekerja dengan cara mendekati daerah bawah grafik fungsi f(x) sebagai trapesium dan menghitung luas daerah yang terasir. Estimasi berdasarkan satu interval : Estimasi berdasarkan 2 interval : R(0,0)R(0,0) R(0,0)R(0,0) : berdasarkan pada estimasi sebelumnya dan h[f(a)+(h)]h[f(a)+(h)] h[f(a)+(h)]h[f(a)+(h)] : berdasarkan pada titik baru Listing Program: \u00b6 #Mendefinisikan fungsi def fungsi ( x ): y = 1 / ( 1 + x ) return y print ( \" \" ) print ( \"Rumus yang digunakan adalah = f(x) = 1/(1+x)\" ) print ( \" \" ) a = float ( input ( \"Inputkan batas bawah : \" )) b = float ( input ( \"Masukkan batas atas : \" )) c = int ( input ( \"Masukkan n : \" )) error = [] print ( \" \" ) for iterasi in range ( 0 , c ): n = 2 ** iterasi h = ( b - a ) / n xi = a y = 0 for i in range ( 1 , n ): xi = xi + h y += fungsi ( xi ) trapezoid = (( h ) * ( fungsi ( a ) + ( 2 * y ) + fungsi ( b ))) / 2 error . append ( trapezoid ) print ( iterasi + 1 , \" \\t\\t \" , n , \" \\t\\t \" , trapezoid ) print ( error [ iterasi - 1 ]) print ( error [ iterasi ]) hasil = ( error [ iterasi - 1 ] - error [ iterasi ]) print ( \"estimasi error =\" , hasil ) Output: \u00b6 Rumus yang digunakan adalah = f(x) = 1/(1+x) Inputkan batas bawah : 2 Masukkan batas atas : 4 Masukkan n : 7 1 1 0.5333333333333333 2 2 0.5166666666666666 3 4 0.5123015873015873 4 8 0.5111956455996705 5 16 0.5109181945162025 6 32 0.5108487705480642 7 64 0.5108314107176335 0.5108487705480642 0.5108314107176335 estimasi error = 1.735983043071876e-05 MathJax.Hub.Config({ tex2jax:{inlineMath:[['$$','$$']]} });","title":"Tugas 4"},{"location":"tugas4/#recursive-trapezoid","text":"Metode trapesium merupakan metode integrasi numerik yang didasarkan pada penjumlahan segmen-segmen berbentuk trapesium. Apabila sebuah integral didekati dengan metode trapesium dengan satu segmen saja. Maka dapat dituliskan persamaan sebagai berikut : Aturan trapesium bekerja dengan cara mendekati daerah bawah grafik fungsi f(x) sebagai trapesium dan menghitung luas daerah yang terasir. Estimasi berdasarkan satu interval : Estimasi berdasarkan 2 interval : R(0,0)R(0,0) R(0,0)R(0,0) : berdasarkan pada estimasi sebelumnya dan h[f(a)+(h)]h[f(a)+(h)] h[f(a)+(h)]h[f(a)+(h)] : berdasarkan pada titik baru","title":"Recursive Trapezoid"},{"location":"tugas4/#listing-program","text":"#Mendefinisikan fungsi def fungsi ( x ): y = 1 / ( 1 + x ) return y print ( \" \" ) print ( \"Rumus yang digunakan adalah = f(x) = 1/(1+x)\" ) print ( \" \" ) a = float ( input ( \"Inputkan batas bawah : \" )) b = float ( input ( \"Masukkan batas atas : \" )) c = int ( input ( \"Masukkan n : \" )) error = [] print ( \" \" ) for iterasi in range ( 0 , c ): n = 2 ** iterasi h = ( b - a ) / n xi = a y = 0 for i in range ( 1 , n ): xi = xi + h y += fungsi ( xi ) trapezoid = (( h ) * ( fungsi ( a ) + ( 2 * y ) + fungsi ( b ))) / 2 error . append ( trapezoid ) print ( iterasi + 1 , \" \\t\\t \" , n , \" \\t\\t \" , trapezoid ) print ( error [ iterasi - 1 ]) print ( error [ iterasi ]) hasil = ( error [ iterasi - 1 ] - error [ iterasi ]) print ( \"estimasi error =\" , hasil )","title":"Listing Program:"},{"location":"tugas4/#output","text":"Rumus yang digunakan adalah = f(x) = 1/(1+x) Inputkan batas bawah : 2 Masukkan batas atas : 4 Masukkan n : 7 1 1 0.5333333333333333 2 2 0.5166666666666666 3 4 0.5123015873015873 4 8 0.5111956455996705 5 16 0.5109181945162025 6 32 0.5108487705480642 7 64 0.5108314107176335 0.5108487705480642 0.5108314107176335 estimasi error = 1.735983043071876e-05 MathJax.Hub.Config({ tex2jax:{inlineMath:[['$$','$$']]} });","title":"Output:"},{"location":"tugas5/","text":"Richardson Extrapolasion \u00b6 Dalam analisis numerik, Richardson Extrapolation adalah metode percepatan urutan, yang digunakan untuk meningkatkan laju konvergensi suatu urutan. Dinamai Lewis Fry Richardson , yang memperkenalkan teknik ini pada awal abad ke-20. Dalam kata-kata Borkhoff dan Rota, \"kegunaannya untuk perhitungan praktis sulit ditaksir terlalu tinggi\". Richardson Extrapolation termasuk integrasi Romberg, yang menerapkan ekstrapolasi Richardson pada aturan trapesium, dan algoritma Bulirsch-Stoer untuk menyelesaikan persamaan diferensial biasa. Rumus : ( f (x + h) - f (x - h) ) / (2 h) ( f (x + h) - f (x - h) ) / (2 h) untuk nilai h yang sangat kecil, dua fungsi evaluasi f (x + h) f (x + h) dan f (x - h) f (x - h) akan menjadi kira-kira sama, dan oleh karena itu pembatalan subtraktif akan terjadi. Oleh karena itu, tidak disarankan untuk menggunakan nilai h yang semakin kecil. Kita dapat mencoba untuk memperkirakan nilai tepat e e dengan perkiraan a(h) a(h) . Dalam hal ini, e e adalah turunan dari f (1) (x) f (1) (x) dan perkiraannya adalah ( h ) = (f (x + h) - f (x - h)) / (2 h) ( h ) = (f (x + h) - f (x - h)) / (2 h) . Misalkan sekarang kesalahan aproksimasi didefinisikan oleh serangkaian bentuk Taylor : e = a(h) + K hn + o(hn) e = a(h) + K hn + o(hn) Apabila menggunakan h / 2 h / 2 : e = a(h/2) + K (h/2)n + o((h/2)n) e = a(h/2) + K (h/2)n + o((h/2)n) = a(h/2) + K/2n hn + o(hn) = a(h/2) + K/2n hn + o(hn) Mengalikan kedua ekspresi ini dengan 2n 2n dan mengurangi hasil persamaan pertama 2ne \u2212 e = 2na(h/2) \u2212 a(h) + K/2n hn \u2212 K hn + o(hn) 2ne \u2212 e = 2na(h/2) \u2212 a(h) + K/2n hn \u2212 K hn + o(hn) Perhatikan bahwa istilah hn hn dibatalkan dan kita dibiarkan dengan (2n \u2212 1)e = 2na(h/2) \u2212 a(h) + o(hn) (2n \u2212 1)e = 2na(h/2) \u2212 a(h) + o(hn) Jika kita melihat seri Taylor lengkap untuk rumus perbedaan-terpusat yang terpusat, kita perhatikan bahwa istilah kesalahannya dalam bentuk Knhn Knhn . Dapat kita tulis dengan : K1 = \u22121/6 f(3)(x)h2, etc. K1 = \u22121/6 f(3)(x)h2, etc. Listing Program \u00b6 from math import * def zeros ( n , m ): Z = [] for i in range ( n ): Z . append ([ 0 ] * m ) return Z def D ( Func , a , h ): return ( Func ( a + h ) - Func ( a - h )) / ( 2 * h ) def Richardson_dif ( func , a ): k = 9 L = zeros ( k , k ) for I in range ( k ): L [ I ][ 0 ] = D ( func , a , 1 / ( 2 ** ( I + 1 ))) for j in range ( 1 , k ): for i in range ( k - j ): L [ i ][ j ] = (( 4 ** ( j )) * L [ i + 1 ][ j - 1 ] - L [ i ][ j - 1 ]) / ( 4 ** ( j ) - 1 ) return L [ 0 ][ k - 1 ] print ( '======================================================================' ) print ( '<<<<<<<<<<<<<<<<<<<<<<<Richardson Extrapolation>>>>>>>>>>>>>>>>>>>>>>>' ) print ( '======================================================================' ) print ( 'SOAL \\n f(x) = \u20130.1x4 \u2013 0.15x3 \u2013 0.5x2 \u2013 0.25x + 1.2 \\n ' 'Mulai dengan h1 = 0.5 dan h2 = 0.25, \\n hitung estimasi dengan f\u2019(0.5) menggunakan Richardson Extrapolation' ) print ( '======================================================================' ) print ( 'f = -0.1*x**4 - 0.15*x**3 - 0.5*x**2 - 0.25*x + 1.2 dengan x = 0.5' ) print ( ' %04.20f ' % Richardson_dif ( lambda x : - 0.1 * x ** 4 - 0.15 * x ** 3 - 0.5 * x ** 2 - 0.25 * x + 1.2 , 0.5 )) print ( '======================================================================' ) print ( 'diff(2**cos(pi+sin(x)) dengan x = pi/2 adalah = %04.20f ' % Richardson_dif ( lambda x : 2 ** cos ( pi + sin ( x )), pi / 3 )) print ( '======================================================================' ) Output \u00b6 ====================================================================== <<<<<<<<<<<<<<<<<<<<<<<Richardson Extrapolation>>>>>>>>>>>>>>>>>>>>>>> ====================================================================== SOAL f(x) = \u20130.1x4 \u2013 0.15x3 \u2013 0.5x2 \u2013 0.25x + 1.2 Mulai dengan h1 = 0.5 dan h2 = 0.25, hitung estimasi dengan f\u2019(0.5) menggunakan Richardson Extrapolation ====================================================================== f = -0.1*x**4 - 0.15*x**3 - 0.5*x**2 - 0.25*x + 1.2 dengan x = 0.5 -0.91250000000000530687 ====================================================================== diff(2**cos(pi+sin(x)) dengan x = pi/2 adalah = 0.16849558398154249050 ====================================================================== MathJax.Hub.Config({ tex2jax:{inlineMath:[['$$','$$']]} });","title":"Tugas 5"},{"location":"tugas5/#richardson-extrapolasion","text":"Dalam analisis numerik, Richardson Extrapolation adalah metode percepatan urutan, yang digunakan untuk meningkatkan laju konvergensi suatu urutan. Dinamai Lewis Fry Richardson , yang memperkenalkan teknik ini pada awal abad ke-20. Dalam kata-kata Borkhoff dan Rota, \"kegunaannya untuk perhitungan praktis sulit ditaksir terlalu tinggi\". Richardson Extrapolation termasuk integrasi Romberg, yang menerapkan ekstrapolasi Richardson pada aturan trapesium, dan algoritma Bulirsch-Stoer untuk menyelesaikan persamaan diferensial biasa. Rumus : ( f (x + h) - f (x - h) ) / (2 h) ( f (x + h) - f (x - h) ) / (2 h) untuk nilai h yang sangat kecil, dua fungsi evaluasi f (x + h) f (x + h) dan f (x - h) f (x - h) akan menjadi kira-kira sama, dan oleh karena itu pembatalan subtraktif akan terjadi. Oleh karena itu, tidak disarankan untuk menggunakan nilai h yang semakin kecil. Kita dapat mencoba untuk memperkirakan nilai tepat e e dengan perkiraan a(h) a(h) . Dalam hal ini, e e adalah turunan dari f (1) (x) f (1) (x) dan perkiraannya adalah ( h ) = (f (x + h) - f (x - h)) / (2 h) ( h ) = (f (x + h) - f (x - h)) / (2 h) . Misalkan sekarang kesalahan aproksimasi didefinisikan oleh serangkaian bentuk Taylor : e = a(h) + K hn + o(hn) e = a(h) + K hn + o(hn) Apabila menggunakan h / 2 h / 2 : e = a(h/2) + K (h/2)n + o((h/2)n) e = a(h/2) + K (h/2)n + o((h/2)n) = a(h/2) + K/2n hn + o(hn) = a(h/2) + K/2n hn + o(hn) Mengalikan kedua ekspresi ini dengan 2n 2n dan mengurangi hasil persamaan pertama 2ne \u2212 e = 2na(h/2) \u2212 a(h) + K/2n hn \u2212 K hn + o(hn) 2ne \u2212 e = 2na(h/2) \u2212 a(h) + K/2n hn \u2212 K hn + o(hn) Perhatikan bahwa istilah hn hn dibatalkan dan kita dibiarkan dengan (2n \u2212 1)e = 2na(h/2) \u2212 a(h) + o(hn) (2n \u2212 1)e = 2na(h/2) \u2212 a(h) + o(hn) Jika kita melihat seri Taylor lengkap untuk rumus perbedaan-terpusat yang terpusat, kita perhatikan bahwa istilah kesalahannya dalam bentuk Knhn Knhn . Dapat kita tulis dengan : K1 = \u22121/6 f(3)(x)h2, etc. K1 = \u22121/6 f(3)(x)h2, etc.","title":"Richardson Extrapolasion"},{"location":"tugas5/#listing-program","text":"from math import * def zeros ( n , m ): Z = [] for i in range ( n ): Z . append ([ 0 ] * m ) return Z def D ( Func , a , h ): return ( Func ( a + h ) - Func ( a - h )) / ( 2 * h ) def Richardson_dif ( func , a ): k = 9 L = zeros ( k , k ) for I in range ( k ): L [ I ][ 0 ] = D ( func , a , 1 / ( 2 ** ( I + 1 ))) for j in range ( 1 , k ): for i in range ( k - j ): L [ i ][ j ] = (( 4 ** ( j )) * L [ i + 1 ][ j - 1 ] - L [ i ][ j - 1 ]) / ( 4 ** ( j ) - 1 ) return L [ 0 ][ k - 1 ] print ( '======================================================================' ) print ( '<<<<<<<<<<<<<<<<<<<<<<<Richardson Extrapolation>>>>>>>>>>>>>>>>>>>>>>>' ) print ( '======================================================================' ) print ( 'SOAL \\n f(x) = \u20130.1x4 \u2013 0.15x3 \u2013 0.5x2 \u2013 0.25x + 1.2 \\n ' 'Mulai dengan h1 = 0.5 dan h2 = 0.25, \\n hitung estimasi dengan f\u2019(0.5) menggunakan Richardson Extrapolation' ) print ( '======================================================================' ) print ( 'f = -0.1*x**4 - 0.15*x**3 - 0.5*x**2 - 0.25*x + 1.2 dengan x = 0.5' ) print ( ' %04.20f ' % Richardson_dif ( lambda x : - 0.1 * x ** 4 - 0.15 * x ** 3 - 0.5 * x ** 2 - 0.25 * x + 1.2 , 0.5 )) print ( '======================================================================' ) print ( 'diff(2**cos(pi+sin(x)) dengan x = pi/2 adalah = %04.20f ' % Richardson_dif ( lambda x : 2 ** cos ( pi + sin ( x )), pi / 3 )) print ( '======================================================================' )","title":"Listing Program"},{"location":"tugas5/#output","text":"====================================================================== <<<<<<<<<<<<<<<<<<<<<<<Richardson Extrapolation>>>>>>>>>>>>>>>>>>>>>>> ====================================================================== SOAL f(x) = \u20130.1x4 \u2013 0.15x3 \u2013 0.5x2 \u2013 0.25x + 1.2 Mulai dengan h1 = 0.5 dan h2 = 0.25, hitung estimasi dengan f\u2019(0.5) menggunakan Richardson Extrapolation ====================================================================== f = -0.1*x**4 - 0.15*x**3 - 0.5*x**2 - 0.25*x + 1.2 dengan x = 0.5 -0.91250000000000530687 ====================================================================== diff(2**cos(pi+sin(x)) dengan x = pi/2 adalah = 0.16849558398154249050 ====================================================================== MathJax.Hub.Config({ tex2jax:{inlineMath:[['$$','$$']]} });","title":"Output"}]}